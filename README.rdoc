= Naf, a Job Scheduling Rails Engine

== Getting Started

=== Creating Postgres-backed Rails App

1. Create a new rails application (call it whatever you want, for my example it's: myapp), and enter

    rails new myapp
    
    cd myapp

2. Create a new Postgres development database

    createdb -O postgres myapp_development

3. Delete the sqlite gem dependency from your Gemfile, and add the Postgres adapter gem, the Fiksu Af gem, and Fiksu Naf gem

    gem 'pg'
    gem 'af',  :git => 'git@github.com:fiksu/af.git'
    gem 'naf', :git => 'git@github.com:fiksu/naf.git'

3. Edit your config/database.yml file

    development:
        adapter: postgresql
        encoding: UTF8
        username: postgres
        host: localhost
        database: myapp_development

=== Importing Naf

1. Now import these new gems
    
    bundle install

2. Run the generator to copy a configuration YAML file, and an initializer into your main applications code base.
   You can optionally provide an argument which specifies the Postgres schema which the Naf tables will reside in, default is: 'myapp_job_system'

    rails generate naf_system [myapp_job_system]

3. This has created/edited the following files:

    config/job_system_schema_config.yml (Specifies the schema_name)
    config/initializers/job_system_initializer.rb  (Loads the schema_name)
    config/routes.rb  (Edited to mount Naf as a rails engine, at the default path "/job_system")

4. Now bring in all of the Naf schema migrations.  

    rake naf:install:migrations

=== Using a Non-Primary Database (Skip if you aren't)

1. By default the Naf tables live on your primary database.  You can optionally configure the naf tables to live on a specific database connection, add entries: naf_development, naf_production etc. to your config/database.yml.  For example, if you had a database named: sparedb_development, you can have the Naf tables live there by adding:

    naf_development:
        adapter: postgresql
        encoding: UTF8
        username: postgres
        host: localhost
        database: sparedb_development

2. Now you must run this rake command to isolate the migrations from your main apps migrations.   This moves all naf migrations to:  db/naf/migrate.  When you bundle the latest version of Naf, there may be new schema migrations, so you must isolate those as well.  Run this command, and make sure to add it to your deploy script.

    rake naf:isolate:migrations

3. Now that all of the latest migrations are isolated from the main app, they work on your non-primary database.  When you bundle the latest version of Naf, and isolate new migrations, they have to be run.  Run this command and make sure to add it to your deploy script.

    rake naf:db:migrate

=== Run the migrations

1. Now if you are using your Primary database for Naf, then your app controls the migrations.  So run them (does nothing if you using a non-primary database, and have run #2, and #3 from the above section):

    rake db:migrate

2. Try running the Rails console, and see that you have the Naf models loaded, and mapped to the database.

    rails console
    Naf::Affinity.all

=== Configure

1. If you use a base controller for your application's authentication, edit the line from config/initializers/naf_initializer.rb

    Naf.controller_class = "::ApplicationController"

2. If you want use your non-primary database for Naf tables (skip if you aren't). edit the line from config/initializers/naf_initializer.rb to read:

    Naf.model_class = "::Naf::OtherBase"

3. Now you can visit the Naf Job System UI mounted at the default path '/job_system' (Configurable in config/routes.rb)

4. You can change the name shown on the page, edit the 'main_app_title' attribute in config/job_system_config.yml.

=== Teardown

1. Undo all of this setup by running the following rake task, rolling back all the naf migrations, and deleting all copied/installed files.  WARNING: This will wipe away all of your data in your Naf tables.

     rake naf:teardown

== Using Naf
  